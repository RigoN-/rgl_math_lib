<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=KOI8-R">
<title>Создание и использование библиотек</title>
</head>
<body>
<a href="http://mech.math.msu.su/%7Ezubr/linux_teaching.html">Возврат к оглавлению</a>
<br>
Будет на примере показано, как создавать библиотеки: статические, разделяемые и динамические.<hr>
Создание статической библиотеки<br>
Файл libhello.h содержит прототип библиотечной функции<br>
<pre>void hello(void);
</pre>

Файл libhello.c содержит реализацию библиотечной функции
<pre>#include <stdio.h>
void hello(void){
 printf("Hello, library world.\n");
}
</stdio.h></pre>
Файл demo_use.c содержит вызов библиотечной функции.
<pre>#include "libhello.h"
int main(){
  hello();
  return 0;
}
</pre>
Теперь создадим статическую библиотеку и создадим исполняемый файл на основе
libhello.h, libhello.c, demo_use.c .
Ключ -g можно удалить, он используется только для проведения отладки при помощи gdb.
<pre>#Создаем объектный файл
gcc -Wall -g -c -o libhello-static.o libhello.c
#Создаем статическую библиотеку
ar rcs libhello-static.a libhello-static.o
#Если обладаете правами суперпользователя, то можно выполнить
#cp libhello-static.a /usr/local/lib/
#Иначе оставляем статическую библиотеку в текущей директории
#Создаем объектный файл
gcc -Wall -g -c demo_use.c -o demo_use.o
#Создаем исполняемый файл
#-L. - этот параметр указывает компилятору, что библиотеку следует искать в текущей директории.
#-lhello-static - этот параметр указывает компилятору, что библиотека помещается в файле
#libhello-static.расширение (.a, .o, .so).
gcc -g -o demo_use_static demo_use.o -L. -lhello-static
#Выполнение исполняемого файла
./demo_use_static
</pre>
Для выполнения исполняемого файла demo_use_static уже не требуется существование 
файла libhello.a. Эта библиотека нужна была только при создании исполняемого файла.

<hr>
Создание разделяемой библиотеки<br>
Способ создания разделяемых библиотек зависит от ОС, однако обычно 
включает два этапа.
Первый этап - создание объектного файла, содержащий код, не зависящий от
 места расположения (Position-Independent Code). Второй этап - создание 
собственно библиотеки.
<pre>#Создаем объектный файл, пригодный впоследствие для создания разделяемой библиотеки.
#Обращаем внимание на ключ -fPIC
gcc -fPIC -Wall -g -c libhello.c
#Создаем разделяемую библиотеку
#-lc  - этот аргумент указывает, что компиляция происходи с участием стандартной C-библиотеки libc, поскольку libhello.o зависит от  libc
#-Wl - предшествует параметрам, передаваемым линкеру (сборщику исполняемого файла) 
gcc -g -shared -Wl,-soname,libhello.so.0 -o libhello.so.0.0 libhello.c -lc
#Если обладаете правами суперпользователя, то можно выполнить
# cp libhello.so.0.0 /usr/local/lib/
#Ключ -n указывает ldconfig, что обработать нужно только директории указанные в командной строке, в данном случае - только текущую директорию. 
/sbin/ldconfig -v -n .
#Создание символической ссылки
ln -sf libhello.so.0 libhello.so
#Создание объектного файла
gcc -Wall -g -c demo_use.c -o demo_use.o
#Создание исполняемого файла:
#-L. - этот параметр указывает компилятору, что поиск при компиляции необходимо проводить в текущей директории
#-lhello - этот параметр определяет имя файла, в котором содержится необходимая библиотека
gcc -g -o demo_use demo_use.o -L. -lhello

#Для выполнения необходимо, чтобы в переменной окружения LD_LIBRARY_PATH были перечислены через ":" директории, в которых следует искать библиотеки. 
LD_LIBRARY_PATH="." ./demo_use
</pre>
Для успешного выполнения необходимо, что файлы, содержащие библиотеки, 
присутствовали
в указанных директориях. Если файлов нет в этих директориях, происходит 
поиск в стандарнтных директориях /lib и /usr/lib.

По итогам создания этой статической библиотеки у вас возникнет
файл libhello.so, являющийся символической ссылкой на файл 
libhello.so.0, который
в свою очередь является символической ссылкой на файл libhello.so.0.0, 
который и содержит разделяемую библиотеку. Числа, идущие после "so." , 
называются версией и релизом библиотеки. Для того, чтобы определить с 
какими версиями библиотек скомпилирована программа,
достаточно воспользоваться командой 
<pre>ldd demo_use
</pre>
При выполнении программы происходит поиск библиотеки с требуемым именем и
 версией, то есть поиск файл с именем 
lib&lt;имя_библиотеки&gt;.so.номер_версии. Этот файл является 
символической ссылкой на файл, содержащий собственно библиотеку. В имени
 этого файла уже будет присутствовать номер релиза. Такой механизм 
позволяет иметь несколько версий одной библиотеки.
<hr>
Использование динамических библиотек<br>

Необходимо сначала создать разделяемую библиотеку.
Далее приводится текст программы, в которой происходит
динамическое подгружение библиотеки.
<pre>/* demo_dynamic.c -- demonstrate dynamic loading and
     use of the "hello" routine */


/* Need dlfcn.h for the routines to
     dynamically load libraries */
#include <dlfcn.h>

#include <stdlib.h>
#include <stdio.h>

/* Note that we don't have to include "libhello.h".
     However, we do need to specify something related;
        we need to specify a type that will hold the value
           we're going to get from dlsym(). */

/* The type "simple_demo_function" describes a function that
     takes no arguments, and returns no value: */

typedef void (*simple_demo_function)(void);


int main(void) {
         const char *error;
          void *module;
           simple_demo_function demo_function;

            /* Load dynamically loaded library */
              module = dlopen("libhello.so", RTLD_LAZY);
              if (!module) {
                        fprintf(stderr, "Couldn't open libhello.so: %s\n",
                              exit(1);
                               }

               /* Get symbol */
               dlerror();
               demo_function = dlsym(module, "hello");
                if ((error = dlerror())) {
                           fprintf(stderr, "Couldn't find hello: %s\n", error);
                              exit(1);
                               }

                 /* Now call the function in the DL library */
                 (*demo_function)();

                  /* All done, close things cleanly */
                  dlclose(module);
                   return 0;
}

</stdio.h></stdlib.h></dlfcn.h></pre>

Компиляция осуществляется следующими командами:

<pre>#создаем объектный файл
gcc -Wall -g -c demo_dynamic.c
#создаем исполняемый файл
#-ldl - этот параметр обеспечивает обращение к библиотеке libdl, которая обеспечивает
динамическое подгружение библиотек
gcc -g -o demo_dynamic demo_dynamic.o -ldl
</pre>
Выполнение программы так же, как в случае разделяемых библиотек.
<pre>LD_LIBRARY_PATH="." ./demo_dynamic
</pre>
Рекомендуется прочитать документацию для функцийй <tt>dlopen</tt>, <tt>dlclose</tt>,
<tt>dlsym</tt>, <tt>dlerror</tt>, <tt>ar</tt>, <tt>ldd</tt>,<tt>nm</tt>.

<hr>
Функции _init и _fini.
<br>
В библиотеке могут содержаться функции со специальными именами _init и _fini.
Функция _init выполняется всегда непосредственно перед загрузкой библиотеки.
Функция _fini выполняется всегда непосредственно перед выгрузкой библиотеки.

Покажем на примере, как скомпилировать библиотеку, содержащую функцию _init.
Файл libhello.c сделаем таким:
<pre>#include <stdio.h>
void _init(void){
 printf("Load library!\n");
}
void hello(void){
 printf("Hello, library world?\n");
}

</stdio.h></pre>
Объектный файл libhello.o создается без проблем.
При попытке создать библиотеку получаем ошибку
<pre>gcc  -g -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0 libhello.o -lc
libhello.o: In function `_init':
/home/zubr/demo_library/shared/libhello.c:2: multiple definition of `_init'
/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crti.o(.init+0x0): first defined here
collect2: ld returned 1 exit status
</pre>

Для прояснения  проблемы добавим в ключи компилятора -v. Этот ключ позволяет
получить подробности работа компилятора.
<pre> gcc  -v -g -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0 libhello.o -lc

Reading specs from /usr/lib/gcc-lib/i386-redhat-linux/2.96/specs
gcc version 2.96 20000731 (Red Hat Linux 7.3 2.96-110)
 /usr/lib/gcc-lib/i386-redhat-linux/2.96/collect2 -m elf_i386 -shared -o libhello.so.1.0 /usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crti.o /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtbeginS.o -L/usr/lib/gcc-lib/i386-redhat-linux/2.96 -L/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../.. -soname libhello.so.1 libhello.o -lc -lgcc -lc -lgcc /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtendS.o /usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crtn.o
libhello.o: In function `_init':
/home/zubr/demo_library/shared/libhello.c:2: multiple definition of `_init'
/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crti.o(.init+0x0): first defined here
collect2: ld returned 1 exit status
</pre>

Отсюда видно, что компилятор gcc указывает среди объектных файлов, 
подлежащих компиляции командой collect2, файл /usr/lib/crti.o, который 
содержит функцию _init. Коль скоро имеем две функции с одним и тем же 
именем, получаем ошибку.

Получить желаемое следующим образом. Явно вызовем collect2 с теми же 
аргументами, которые, за исключением 
/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crti.o .
<pre> /usr/lib/gcc-lib/i386-redhat-linux/2.96/collect2 -m elf_i386 -shared -o libhello.so.1.0 /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtbeginS.o -L/usr/lib/gcc-lib/i386-redhat-linux/2.96 -L/usr/lib/gcc-lib/i386-redhat-linux/2.96/../../.. -soname libhello.so.1 libhello.o -lc -lgcc -lc -lgcc /usr/lib/gcc-lib/i386-redhat-linux/2.96/crtendS.o /usr/lib/gcc-lib/i386-redhat-linux/2.96/../../../crtn.o
</pre>
Это успешно создает libhello.1.0. Далее создание библиотеки происходит стандартным образом.
<pre>/sbin/ldconfig -n .
gcc  -Wall -g -c demo_use.c -o demo_use.o
gcc  -g -o demo_use1 demo_use.o -L. -lhello
</pre>
Теперь при выполнении demo_use1 получаем
<pre>LD_LIBRARY_PATH="." ./demo_use1
Load library!
Hello, library world?
</pre>
То есть происходит неявный вызов _init, что и требовалось.
Примечание: На вашей машине файл, содержащий стандартную функцию _init, 
может иметь другое имя. Смотрите внимательно в диагностическую 
информацию gcc.

Ключ -nostartfiles для компилятора gcc позволяет не линковать стартовые 
файлы, в которых присутствуют функции _init и _fini по умолчанию. 
Использование этого ключа также решает проблему.


</body></html>